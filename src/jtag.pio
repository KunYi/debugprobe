
// PIO State Machine 0
// Function: Shift out TMS bits for controlling the JTAG TAP state machine
// TCK is generated via sideset
// TMS is driven on the output pin
.program jtag_tms
.side_set 1 opt                           ; 1-bit sideset, optional, used for TCK edges

.wrap_target
public tms_shift:
    pull                       side 0x0   ; Fetch one word from TX FIFO
    out x, 32                             ; number of TMS bits to send
    pull                                  ; Fetch one word with the actual TMS bits
tms_bitloop:
    out pins, 1           [1]  side 0x0   ; Output TMS bit on TCK falling edge
    jmp x-- tms_bitloop   [1]  side 0x1   ; Sampled by target on rising edge
                                          ; Decrement counter, loop until all bits shifted
                                          ; Falls through when finished
.wrap


// PIO State Machine 1
// TCK is generated via sideset
// TDI is driven on output pin
// TDO is sampled from input pin
.program jtag_tdio
.side_set 1 opt                           ; 1-bit sideset, optional, used for TCK edges

.wrap_target
public tdio_sequence:
    pull                       side 0x0   ; Fetch one word from TX FIFO
    out x, 32                             ; number of TDI bits to send, TDO bits to read
    pull                                  ; Fetch one word with TDI bits
tdio_loop:
    out pins, 1          [1] side 0       ; write to TDI,  on negedge
    in pins, 1           [1] side 1       ; read from TDO, on posedge
    jmp x-- tdio_loop        side 0       ; Decrement counter, repeat until done
    push                                  ; Push captured TDO bits into RX FIFO
.wrap

% c-sdk {

static inline void jtag_tms_program_init(PIO pio, uint sm, uint offset,
                                          uint pin_tms, uint pin_tck) {
    pio_sm_config c = jtag_tms_program_get_default_config(offset);

    // OUT pins (TMS)
    sm_config_set_out_pins(&c, pin_tms, 1);
    sm_config_set_out_shift(&c, false, false, 32);  // left shift, not autopull

    // side-set (TCK)
    sm_config_set_sideset_pins(&c, pin_tck);

    // initial GPIO
    pio_gpio_init(pio, pin_tms);
    pio_gpio_init(pio, pin_tck);
    pio_sm_set_consecutive_pindirs(pio, sm, pin_tms, 1, true);
    pio_sm_set_consecutive_pindirs(pio, sm, pin_tck, 1, true);

    // initial
    pio_sm_set_pins_with_mask(pio, sm, 0, (1u << pin_tms) | (1u << pin_tck));
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, false);


}

static inline void jtag_tdio_program_init(PIO pio, uint sm, uint offset,
                                              uint pin_tdi, uint pin_tdo,
                                              uint pin_tck) {
    pio_sm_config c = jtag_tdio_program_get_default_config(offset);

    // OUT pins (TDI)
    sm_config_set_out_pins(&c, pin_tdi, 1);
    sm_config_set_out_shift(&c, false, false, 32);  // left shift, not autopull

    // IN pins (TDO)
    sm_config_set_in_pins(&c, pin_tdo);
    sm_config_set_in_shift(&c, false, false, 32);   // left shift, not autopush

    // sideset (TCK)
    sm_config_set_sideset_pins(&c, pin_tck);

    //  initial GPIO
    pio_gpio_init(pio, pin_tdi);
    pio_gpio_init(pio, pin_tdo);
    pio_gpio_init(pio, pin_tck);

    pio_sm_set_consecutive_pindirs(pio, sm, pin_tdi, 1, true);   // TDI: output
    pio_sm_set_consecutive_pindirs(pio, sm, pin_tdo, 1, false);  // TDO: input
    pio_sm_set_consecutive_pindirs(pio, sm, pin_tck, 1, true);   // TCK: output

    pio_sm_set_pins_with_mask(pio, sm, 0, (1u << pin_tdi) | (1u << pin_tck));

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, false);
}

static inline void jtag_program_init(PIO pio,
    uint tms_sm, uint tms_offset,
    uint tdio_sm, uint tdio_offset,
    uint pin_tck, uint pin_tms, uint pin_tdi, uint pin_tdo ) {
    jtag_tms_program_init(pio,
    	tms_sm, tms_offset,
	pin_tms, pin_tck);
    jtag_tdio_program_init(pio,
    	tdio_sm, tdio_offset,
	pin_tdi, pin_tdo, pin_tck);
}

%}
